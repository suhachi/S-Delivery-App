# 프로젝트 마스터 스냅샷 v1.0.0 - 프론트엔드 핵심 (Contexts, Hooks, Lib)

**생성일**: 2025-12-10  
**목적**: 프론트엔드 핵심 로직 파일 원본 보관 (Contexts, Hooks, Lib)

---

## 1. Contexts

### src/contexts/AuthContext.tsx

```typescript
import { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { useFirebaseAuth } from '../hooks/useFirebaseAuth';
import { useIsAdmin } from '../hooks/useIsAdmin';

interface User {
  id: string;
  email: string;
  displayName?: string;
  phone?: string;
}

interface AuthContextType {
  user: User | null;
  isAdmin: boolean;
  loading: boolean;
  login: (email: string, password: string) => Promise<any>;
  signup: (email: string, password: string, displayName?: string, phone?: string) => Promise<any>;
  logout: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: ReactNode }) {
  const { user, loading: authLoading, signup, login, logout } = useFirebaseAuth();
  const { isAdmin, loading: adminLoading } = useIsAdmin(user?.id);
  // TEMPORARY TEST OVERRIDE: Force Admin
  // const isAdmin = true;
  // const adminLoading = false;

  const loading = authLoading || adminLoading;

  return (
    <AuthContext.Provider value={{ user, isAdmin, loading, login, signup, logout }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}
```

### src/contexts/CartContext.tsx

```typescript
import { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { MenuOption } from '../types/menu';

export interface CartItem {
  id: string;
  menuId: string;
  name: string;
  price: number;
  quantity: number;
  options?: MenuOption[];
  imageUrl?: string;
}

interface CartContextType {
  items: CartItem[];
  addItem: (item: Omit<CartItem, 'id'>) => void;
  removeItem: (id: string) => void;
  updateQuantity: (id: string, quantity: number) => void;
  clearCart: () => void;
  getTotalPrice: () => number;
  getTotalItems: () => number;
}

const CartContext = createContext<CartContextType | undefined>(undefined);

export function CartProvider({ children }: { children: ReactNode }) {
  const [items, setItems] = useState<CartItem[]>([]);

  // Load cart from localStorage on mount
  useEffect(() => {
    const storedCart = localStorage.getItem('cart');
    if (storedCart) {
      setItems(JSON.parse(storedCart));
    }
  }, []);

  // Save cart to localStorage whenever it changes
  useEffect(() => {
    localStorage.setItem('cart', JSON.stringify(items));
  }, [items]);

  const addItem = (item: Omit<CartItem, 'id'>) => {
    const id = 'cart-' + Date.now() + '-' + Math.random();
    setItems(prev => [...prev, { ...item, id }]);
  };

  const removeItem = (id: string) => {
    setItems(prev => prev.filter(item => item.id !== id));
  };

  const updateQuantity = (id: string, quantity: number) => {
    if (quantity <= 0) {
      removeItem(id);
      return;
    }
    setItems(prev =>
      prev.map(item => (item.id === id ? { ...item, quantity } : item))
    );
  };

  const clearCart = () => {
    setItems([]);
  };

  const getTotalPrice = () => {
    return items.reduce((total, item) => {
      const optionsPrice = item.options?.reduce((sum, opt) => sum + (opt.price * (opt.quantity || 1)), 0) || 0;
      return total + (item.price + optionsPrice) * item.quantity;
    }, 0);
  };

  const getTotalItems = () => {
    return items.reduce((total, item) => total + item.quantity, 0);
  };

  return (
    <CartContext.Provider
      value={{
        items,
        addItem,
        removeItem,
        updateQuantity,
        clearCart,
        getTotalPrice,
        getTotalItems,
      }}
    >
      {children}
    </CartContext.Provider>
  );
}

export function useCart() {
  const context = useContext(CartContext);
  if (context === undefined) {
    throw new Error('useCart must be used within a CartProvider');
  }
  return context;
}
```

### src/contexts/StoreContext.tsx

```typescript
/**
 * StoreContext - 단일 상점 데이터 관리
 * 앱 실행 시 'store/default' 문서를 로드하여 전역 상태로 제공
 */

import { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { doc, onSnapshot } from 'firebase/firestore';
import { db } from '../lib/firebase';
import { Store } from '../types/store';

interface StoreContextValue {
  // 단일 상점 데이터
  store: Store | null;
  loading: boolean;
  error: Error | null;
  refreshStore: () => Promise<void>;
}

const StoreContext = createContext<StoreContextValue | undefined>(undefined);

interface StoreProviderProps {
  children: ReactNode;
}

export function StoreProvider({ children }: StoreProviderProps) {
  const [store, setStore] = useState<Store | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    // 단일 상점 문서 'stores/default' 구독
    const storeRef = doc(db, 'stores', 'default');

    const unsubscribe = onSnapshot(storeRef,
      (snapshot) => {
        if (snapshot.exists()) {
          setStore({
            id: snapshot.id,
            ...snapshot.data(),
          } as Store);
          setError(null);
        } else {
          console.warn('Default store document does not exist!');
          setStore(null);
          // 스토어가 없을 때에 대한 에러 처리는 별도로 하지 않음 (초기 설정 마법사 등이 처리)
        }
        setLoading(false);
      },
      (err) => {
        console.error('Store subscription error:', err);
        if (err.code === 'permission-denied') {
          console.warn('⚠️ Permission denied: Please ensure Firestore security rules are deployed.');
        }
        setError(err);
        setLoading(false);
      }
    );

    return () => unsubscribe();
  }, []);

  const refreshStore = async () => {
    // onSnapshot이 자동으로 업데이트하므로 수동 리프레시는 크게 필요 없으나 인터페이스 유지
    setLoading(true);
    // 실제로는 구독이 유지되므로 로딩 상태만 잠깐 변경하거나 생략 가능
    setTimeout(() => setLoading(false), 500);
  };

  const value: StoreContextValue = {
    store,
    loading,
    error,
    refreshStore,
  };

  return (
    <StoreContext.Provider value={value}>
      {children}
    </StoreContext.Provider>
  );
}

/**
 * StoreContext Hook
 */
export function useStore() {
  const context = useContext(StoreContext);
  if (context === undefined) {
    throw new Error('useStore must be used within a StoreProvider');
  }
  return context;
}
```

---

## 2. Hooks

### src/hooks/useFirebaseAuth.ts

```typescript
import { useState, useEffect } from 'react';
import {
  createUserWithEmailAndPassword,
  signInWithEmailAndPassword,
  signOut as firebaseSignOut,
  onAuthStateChanged,
  updateProfile,
  User as FirebaseUser
} from 'firebase/auth';
import { doc, setDoc, getDoc } from 'firebase/firestore';
import { auth, db } from '../lib/firebase';

interface User {
  id: string;
  email: string;
  displayName?: string;
  phone?: string;
}

// 데모 계정 정보
const DEMO_ACCOUNTS = {
  'user@demo.com': {
    password: 'demo123',
    id: 'demo-user-001',
    email: 'user@demo.com',
    displayName: '데모 사용자',
    isAdmin: false,
  },
  'admin@demo.com': {
    password: 'admin123',
    id: 'demo-admin-001',
    email: 'admin@demo.com',
    displayName: '관리자',
    isAdmin: true,
  },
};

export function useFirebaseAuth() {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  // 데모 모드 확인
  const isDemoMode = auth.app.options.apiKey === 'demo-api-key';

  useEffect(() => {
    // 데모 모드인 경우 로컬 스토리지에서 사용자 정보 로드
    if (isDemoMode) {
      const demoUser = localStorage.getItem('demoUser');
      if (demoUser) {
        setUser(JSON.parse(demoUser));
      }
      setLoading(false);
      return;
    }

    // Firebase 인증 모드
    const unsubscribe = onAuthStateChanged(auth, async (firebaseUser) => {
      if (firebaseUser) {
        // Firestore에서 추가 정보(phone 등) 가져오기
        const userRef = doc(db, 'users', firebaseUser.uid);
        const userDoc = await getDoc(userRef);
        const userData = userDoc.data();

        setUser({
          id: firebaseUser.uid,
          email: firebaseUser.email || '',
          displayName: userData?.displayName || firebaseUser.displayName || undefined, // Firestore 데이터 우선
          phone: userData?.phone || undefined,
        });

        // Firestore에 사용자 문서 생성 (없으면)
        if (!userDoc.exists()) {
          await ensureUserDocument(firebaseUser);
        }
      } else {
        setUser(null);
      }
      setLoading(false);
    });

    return () => unsubscribe();
  }, [isDemoMode]);

  const signup = async (email: string, password: string, displayName?: string, phone?: string) => {
    // 데모 모드
    if (isDemoMode) {
      // 데모 모드에서는 회원가입 시뮬레이션
      const newUser: User = {
        id: `demo-user-${Date.now()}`,
        email,
        displayName: displayName || email.split('@')[0],
        phone: phone || '010-0000-0000',
      };
      setUser(newUser);
      localStorage.setItem('demoUser', JSON.stringify(newUser));
      localStorage.setItem('demoIsAdmin', 'false');
      return;
    }

    // Firebase 모드
    try {
      const userCredential = await createUserWithEmailAndPassword(auth, email, password);

      // 프로필 업데이트
      if (displayName && userCredential.user) {
        await updateProfile(userCredential.user, { displayName });
      }

      // Firestore에 사용자 문서 생성
      await createUserDocument(userCredential.user, displayName, phone);

      return userCredential.user;
    } catch (error) {
      const errorCode = (error as { code?: string }).code || 'unknown';
      throw new Error(getAuthErrorMessage(errorCode));
    }
  };

  const login = async (email: string, password: string) => {
    // 데모 모드
    if (isDemoMode) {
      const demoAccount = DEMO_ACCOUNTS[email as keyof typeof DEMO_ACCOUNTS];

      if (!demoAccount) {
        throw new Error('존재하지 않는 사용자입니다. 데모 계정을 사용해주세요:\n- user@demo.com / demo123\n- admin@demo.com / admin123');
      }

      if (demoAccount.password !== password) {
        throw new Error('잘못된 비밀번호입니다');
      }

      // 데모 계정 로그인
      const { id, email: demoEmail, displayName, isAdmin } = demoAccount;
      const demoUser: User = { id, email: demoEmail, displayName };

      setUser(demoUser);
      localStorage.setItem('demoUser', JSON.stringify(demoUser));
      localStorage.setItem('demoIsAdmin', String(isAdmin));

      return;
    }

    // Firebase 모드
    try {
      const userCredential = await signInWithEmailAndPassword(auth, email, password);
      return userCredential.user;
    } catch (error) {
      const errorCode = (error as { code?: string }).code || 'unknown';
      throw new Error(getAuthErrorMessage(errorCode));
    }
  };

  const logout = async () => {
    // 데모 모드
    if (isDemoMode) {
      setUser(null);
      localStorage.removeItem('demoUser');
      localStorage.removeItem('demoIsAdmin');
      return;
    }

    // Firebase 모드
    try {
      await firebaseSignOut(auth);
    } catch (error) {
      throw new Error('로그아웃에 실패했습니다');
    }
  };

  return { user, loading, signup, login, logout };
}

// Firestore에 사용자 문서 생성
async function createUserDocument(firebaseUser: FirebaseUser, displayName?: string, phone?: string) {
  const userRef = doc(db, 'users', firebaseUser.uid);

  await setDoc(userRef, {
    email: firebaseUser.email,
    displayName: displayName || firebaseUser.email?.split('@')[0] || '',
    phone: phone || '',
    createdAt: new Date(),
    updatedAt: new Date(),
  }, { merge: true });
}

// 사용자 문서 확인 및 생성
async function ensureUserDocument(firebaseUser: FirebaseUser) {
  const userRef = doc(db, 'users', firebaseUser.uid);
  const userDoc = await getDoc(userRef);

  if (!userDoc.exists()) {
    await createUserDocument(firebaseUser, firebaseUser.displayName || undefined);
  }
}

// Firebase 에러 메시지 한글화
function getAuthErrorMessage(errorCode: string): string {
  const errorMessages: Record<string, string> = {
    'auth/email-already-in-use': '이미 사용 중인 이메일입니다',
    'auth/invalid-email': '올바른 이메일 형식이 아닙니다',
    'auth/operation-not-allowed': '이메일/비밀번호 로그인이 비활성화되어 있습니다',
    'auth/weak-password': '비밀번호는 최소 6자 이상이어야 합니다',
    'auth/user-disabled': '비활성화된 계정입니다',
    'auth/user-not-found': '존재하지 않는 사용자입니다',
    'auth/wrong-password': '잘못된 비밀번호입니다',
    'auth/too-many-requests': '너무 많은 시도가 있었습니다. 잠시 후 다시 시도해주세요',
    'auth/network-request-failed': '네트워크 오류가 발생했습니다',
  };

  return errorMessages[errorCode] || '인증 오류가 발생했습니다';
}
```

### src/hooks/useFirestoreCollection.ts

```typescript
import { useState, useEffect, useRef } from 'react';
import {
  Query,
  onSnapshot,
  DocumentData,
  queryEqual
} from 'firebase/firestore';

interface UseFirestoreCollectionResult<T> {
  data: T[];
  loading: boolean;
  error: Error | null;
}

export function useFirestoreCollection<T extends DocumentData>(
  query: Query | null
): UseFirestoreCollectionResult<T> {
  const [data, setData] = useState<T[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  // 쿼리 객체 참조 안정화 (Deep Compare)
  const queryRef = useRef<Query | null>(query);

  // 렌더링 도중에 ref 업데이트 (useEffect보다 먼저 실행되어야 함)
  if (!queryEqual(queryRef.current, query)) {
    queryRef.current = query;
  }

  // 이제 useEffect는 안정화된 queryRef.current가 변경될 때만 실행됨
  // 즉, 쿼리의 내용이 실제로 바뀌었을 때만 재구독 발생
  useEffect(() => {
    const activeQuery = queryRef.current;

    if (!activeQuery) {
      setLoading(false);
      return;
    }

    setLoading(true);

    try {
      const unsubscribe = onSnapshot(
        activeQuery,
        (snapshot) => {
          const items = snapshot.docs.map(doc => ({
            id: doc.id,
            ...doc.data(),
          })) as T[];

          setData(items);
          setLoading(false);
          setError(null);
        },
        (err) => {
          console.error(`Firestore collection error:`, err);
          setError(err as Error);
          setLoading(false);
        }
      );

      return () => unsubscribe();
    } catch (err) {
      setError(err as Error);
      setLoading(false);
    }
  }, [queryRef.current]); // query 대신 queryRef.current 사용

  return { data, loading, error };
}
```

### src/hooks/useFirestoreDocument.ts

```typescript
import { useState, useEffect } from 'react';
import { doc, onSnapshot, DocumentData } from 'firebase/firestore';
import { db } from '../lib/firebase';

interface UseFirestoreDocumentResult<T> {
  data: T | null;
  loading: boolean;
  error: Error | null;
}

export function useFirestoreDocument<T extends DocumentData>(
  collectionName: string | string[],
  documentId: string | null | undefined
): UseFirestoreDocumentResult<T> {
  // 안정적인 의존성 키 생성 (배열인 경우 문자열로 결합)
  const collectionPath = Array.isArray(collectionName)
    ? collectionName.join('/')
    : collectionName;

  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    if (!documentId) {
      setData(null);
      setLoading(false);
      return;
    }

    setLoading(true);

    try {
      // collectionPath(문자열)를 사용하여 참조 생성
      const docRef = doc(db, collectionPath, documentId);

      const unsubscribe = onSnapshot(
        docRef,
        (snapshot) => {
          if (snapshot.exists()) {
            setData({
              id: snapshot.id,
              ...snapshot.data(),
            } as T);
          } else {
            setData(null);
          }
          setLoading(false);
          setError(null);
        },
        (err) => {
          console.error(`Firestore document error (${collectionPath}/${documentId}):`, err);
          setError(err as Error);
          setLoading(false);
        }
      );

      return () => unsubscribe();
    } catch (err) {
      setError(err as Error);
      setLoading(false);
    }
  }, [collectionPath, documentId]); // 안정된 문자열 키 사용

  return { data, loading, error };
}
```

### src/hooks/useIsAdmin.ts

```typescript
import { useState, useEffect } from 'react';
import { doc, onSnapshot } from 'firebase/firestore';
import { db, auth } from '../lib/firebase';

export function useIsAdmin(userId: string | null | undefined) {
  const [isAdmin, setIsAdmin] = useState(false);
  const [loading, setLoading] = useState(true);

  // 데모 모드 확인
  const isDemoMode = auth.app.options.apiKey === 'demo-api-key';

  useEffect(() => {
    if (!userId) {
      setIsAdmin(false);
      setLoading(false);
      return;
    }

    // 데모 모드인 경우 로컬 스토리지에서 확인
    if (isDemoMode) {
      const demoIsAdmin = localStorage.getItem('demoIsAdmin') === 'true';
      setIsAdmin(demoIsAdmin);
      setLoading(false);
      return;
    }

    // Firestore에서 관리자 권한 확인 (System Admin OR Store Owner)
    // 1. System Admin 체크
    const adminRef = doc(db, 'admins', userId);

    // 2. Store Owner 체크 (단일 상점 모드: 'default')
    const adminStoreRef = doc(db, 'adminStores', `${userId}_default`);

    // 두 경로 중 하나라도 존재하면 관리자로 인정
    // 실시간 리스너를 각각 연결하는 대신, 편의상 하나씩 확인하거나
    // 여기서는 onSnapshot을 두 번 호출하여 상태를 합칩니다.

    let isSystemAdmin = false;
    let isStoreOwner = false;

    // 리스너 관리를 위한 클린업 함수 배열
    const unsubscribes: (() => void)[] = [];

    const updateAdminStatus = () => {
      setIsAdmin(isSystemAdmin || isStoreOwner);
      setLoading(false);
    };

    const unsubAdmin = onSnapshot(adminRef, (doc) => {
      isSystemAdmin = doc.exists() && doc.data()?.isAdmin === true;
      updateAdminStatus();
    }, (err) => {
      console.error('System admin check failed:', err);
      // 에러 시 무시 (false)
    });
    unsubscribes.push(unsubAdmin);

    const unsubStore = onSnapshot(adminStoreRef, (doc) => {
      isStoreOwner = doc.exists(); // adminStores에 레코드가 있으면 권한 보유로 간주 (role 체크 추가 가능)
      updateAdminStatus();
    }, (err) => {
      console.error('Store owner check failed:', err);
    });
    unsubscribes.push(unsubStore);

    return () => {
      unsubscribes.forEach(unsub => unsub());
    };
  }, [userId, isDemoMode]);

  return { isAdmin, loading };
}
```

---

## 3. Lib

### src/lib/firebase.ts

```typescript
import { initializeApp } from 'firebase/app';
import { getAuth } from 'firebase/auth';
import { initializeFirestore } from 'firebase/firestore';
import { getStorage } from 'firebase/storage';
import { getMessaging, isSupported } from 'firebase/messaging';

// Firebase 설정
// 실제 프로젝트에서는 .env 파일에서 불러옵니다
const firebaseConfig = {
  apiKey: "AIzaSyCKS_ilGLymEaBjdF6oVKPKKkPc2dNCxQU",
  authDomain: "simple-delivery-app-9d347.firebaseapp.com",
  projectId: "simple-delivery-app-9d347",
  storageBucket: "simple-delivery-app-9d347.firebasestorage.app",
  messagingSenderId: "665529206596",
  appId: "1:665529206596:web:6e5542c21b7fe765a0b911",
  measurementId: "G-FZ74JXV42S"
};

// Firebase 초기화
const app = initializeApp(firebaseConfig);

// Firebase 서비스 초기화
export const auth = getAuth(app);
export const db = initializeFirestore(app, {
  ignoreUndefinedProperties: true
});
export const storage = getStorage(app);

// Firebase Cloud Messaging (FCM) - 선택적
let messaging: any = null;
if (typeof window !== 'undefined') {
  isSupported().then((supported) => {
    if (supported) {
      messaging = getMessaging(app);
    }
  });
}
export { messaging };

export default app;
```

### src/lib/nicepayClient.ts

```typescript
import { NicepayRequestParams } from '../types/global';

const NICEPAY_SCRIPT_URL = 'https://pay.nicepay.co.kr/v1/js/';

/**
 * NICEPAY JS SDK를 동적으로 로드합니다.
 */
export function loadNicepayScript(): Promise<void> {
    return new Promise((resolve, reject) => {
        if (window.AUTHNICE) {
            resolve();
            return;
        }

        const script = document.createElement('script');
        script.src = NICEPAY_SCRIPT_URL;
        script.async = true;
        script.onload = () => resolve();
        script.onerror = () => reject(new Error('NICEPAY Script load failed'));
        document.body.appendChild(script);
    });
}

/**
 * NICEPAY 결제창을 호출합니다.
 * @param params 결제 요청 파라미터
 */
export async function requestNicepayPayment(params: NicepayRequestParams): Promise<void> {
    await loadNicepayScript();

    if (!window.AUTHNICE) {
        throw new Error('NICEPAY SDK SDK not loaded');
    }

    window.AUTHNICE.requestPay({
        ...params,
        method: 'card', // 기본적으로 카드 결제
    });
}
```

### src/lib/storeAccess.ts

```typescript
/**
 * 상점 접근 권한 관리 유틸리티
 * adminStores 컬렉션을 통해 관리자-상점 매핑 관리
 */

import { db } from './firebase';
import { collection, query, where, getDocs, addDoc, deleteDoc, doc } from 'firebase/firestore';
import { AdminStore, StorePermission } from '../types/store';

/**
 * 관리자가 접근 가능한 상점 목록 조회
 */
export async function getAdminStores(adminUid: string): Promise<AdminStore[]> {
  // adminUid 유효성 검사
  if (!adminUid || typeof adminUid !== 'string') {
    console.warn('getAdminStores called with invalid adminUid:', adminUid);
    return [];
  }

  try {
    const q = query(
      collection(db, 'adminStores'),
      where('adminUid', '==', adminUid)
    );
    
    const snapshot = await getDocs(q);
    return snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
    })) as AdminStore[];
  } catch (error) {
    console.error('Error in getAdminStores:', error);
    return [];
  }
}

/**
 * 특정 상점의 관리자 목록 조회
 */
export async function getStoreAdmins(storeId: string): Promise<AdminStore[]> {
  const q = query(
    collection(db, 'adminStores'),
    where('storeId', '==', storeId)
  );
  
  const snapshot = await getDocs(q);
  return snapshot.docs.map(doc => ({
    id: doc.id,
    ...doc.data(),
  })) as AdminStore[];
}

/**
 * 관리자가 특정 상점에 접근 가능한지 확인
 */
export async function hasStoreAccess(
  adminUid: string,
  storeId: string
): Promise<boolean> {
  const adminStores = await getAdminStores(adminUid);
  return adminStores.some(as => as.storeId === storeId);
}

/**
 * 관리자가 특정 권한을 가지고 있는지 확인
 */
export async function hasPermission(
  adminUid: string,
  storeId: string,
  permission: StorePermission
): Promise<boolean> {
  const adminStores = await getAdminStores(adminUid);
  const adminStore = adminStores.find(as => as.storeId === storeId);
  
  if (!adminStore) return false;
  
  // owner는 모든 권한 보유
  if (adminStore.role === 'owner') return true;
  
  return adminStore.permissions.includes(permission);
}

/**
 * 관리자를 상점에 추가
 */
export async function addAdminToStore(
  adminUid: string,
  storeId: string,
  role: 'owner' | 'manager' | 'staff',
  permissions: StorePermission[]
): Promise<string> {
  const adminStoreData = {
    adminUid,
    storeId,
    role,
    permissions,
    createdAt: new Date(),
  };
  
  const docRef = await addDoc(collection(db, 'adminStores'), adminStoreData);
  return docRef.id;
}

/**
 * 상점에서 관리자 제거
 */
export async function removeAdminFromStore(adminStoreId: string): Promise<void> {
  await deleteDoc(doc(db, 'adminStores', adminStoreId));
}

/**
 * 기본 권한 세트
 */
export const DEFAULT_PERMISSIONS: Record<string, StorePermission[]> = {
  owner: [
    'manage_menus',
    'manage_orders',
    'manage_coupons',
    'manage_reviews',
    'manage_notices',
    'manage_events',
    'manage_store_settings',
    'view_analytics',
  ],
  manager: [
    'manage_menus',
    'manage_orders',
    'manage_coupons',
    'manage_reviews',
    'view_analytics',
  ],
  staff: [
    'manage_orders',
    'view_analytics',
  ],
};
```

### src/lib/firestorePaths.ts

```typescript
/**
 * Firestore 경로 헬퍼
 * 멀티 테넌트 데이터 격리를 위한 경로 생성 유틸리티
 * 
 * 기존: collection(db, 'menus')
 * 변경: collection(db, getMenusPath(storeId))
 */

/**
 * 상점별 메뉴 경로
 * stores/{storeId}/menus
 */
export function getMenusPath(storeId: string): string {
  return `stores/${storeId}/menus`;
}

/**
 * 상점별 주문 경로
 * stores/{storeId}/orders
 */
export function getOrdersPath(storeId: string): string {
  return `stores/${storeId}/orders`;
}

/**
 * 상점별 쿠폰 경로
 * stores/{storeId}/coupons
 */
export function getCouponsPath(storeId: string): string {
  return `stores/${storeId}/coupons`;
}

/**
 * 상점별 리뷰 경로
 * stores/{storeId}/reviews
 */
export function getReviewsPath(storeId: string): string {
  return `stores/${storeId}/reviews`;
}

/**
 * 상점별 공지사항 경로
 * stores/{storeId}/notices
 */
export function getNoticesPath(storeId: string): string {
  return `stores/${storeId}/notices`;
}

/**
 * 상점별 이벤트 경로
 * stores/{storeId}/events
 */
export function getEventsPath(storeId: string): string {
  return `stores/${storeId}/events`;
}

/**
 * 상점별 사용 쿠폰 경로
 * stores/{storeId}/couponUsages
 */
export function getCouponUsagesPath(storeId: string): string {
  return `stores/${storeId}/couponUsages`;
}

/**
 * 모든 경로를 한 번에 가져오기
 */
export function getStorePaths(storeId: string) {
  return {
    menus: getMenusPath(storeId),
    orders: getOrdersPath(storeId),
    coupons: getCouponsPath(storeId),
    reviews: getReviewsPath(storeId),
    notices: getNoticesPath(storeId),
    events: getEventsPath(storeId),
    couponUsages: getCouponUsagesPath(storeId),
  };
}
```

### src/lib/firestoreExamples.ts

```typescript
/**
 * Firestore 데이터 격리 사용 예제
 * 실제 코드에서 이렇게 사용하세요
 */

import { db } from '../config/firebase';
import { collection, query, where, getDocs, addDoc, updateDoc, deleteDoc, doc } from 'firebase/firestore';
import { getMenusPath, getOrdersPath, getCouponsPath, getReviewsPath } from './firestorePaths';

/**
 * ❌ 잘못된 방법 (멀티 테넌트 미지원)
 */
export async function getBadMenus() {
  const snapshot = await getDocs(collection(db, 'menus'));
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
}

/**
 * ✅ 올바른 방법 (멀티 테넌트 지원)
 */
export async function getGoodMenus(storeId: string) {
  const snapshot = await getDocs(collection(db, getMenusPath(storeId)));
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
}

/**
 * 예제 1: 메뉴 조회
 */
export async function getMenusByStore(storeId: string) {
  // ❌ const menusRef = collection(db, 'menus');
  // ✅ 
  const menusRef = collection(db, getMenusPath(storeId));
  const snapshot = await getDocs(menusRef);
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
}

/**
 * 예제 2: 메뉴 추가
 */
export async function addMenu(storeId: string, menuData: any) {
  // ❌ const menusRef = collection(db, 'menus');
  // ✅
  const menusRef = collection(db, getMenusPath(storeId));
  return await addDoc(menusRef, menuData);
}

/**
 * 예제 3: 주문 조회 (사용자별)
 */
export async function getUserOrders(storeId: string, userId: string) {
  // ❌ const ordersRef = collection(db, 'orders');
  // ✅
  const ordersRef = collection(db, getOrdersPath(storeId));
  const q = query(ordersRef, where('userId', '==', userId));
  const snapshot = await getDocs(q);
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
}

/**
 * 예제 4: 쿠폰 조회
 */
export async function getActiveCoupons(storeId: string) {
  // ❌ const couponsRef = collection(db, 'coupons');
  // ✅
  const couponsRef = collection(db, getCouponsPath(storeId));
  const q = query(couponsRef, where('active', '==', true));
  const snapshot = await getDocs(q);
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
}

/**
 * 예제 5: 리뷰 추가
 */
export async function addReview(storeId: string, reviewData: any) {
  // ❌ const reviewsRef = collection(db, 'reviews');
  // ✅
  const reviewsRef = collection(db, getReviewsPath(storeId));
  return await addDoc(reviewsRef, reviewData);
}

/**
 * 사용 예시:
 * 
 * // StoreContext에서 storeId 가져오기
 * const { storeId } = useStore();
 * 
 * // 메뉴 조회
 * const menus = await getMenusByStore(storeId);
 * 
 * // 주문 조회
 * const orders = await getUserOrders(storeId, user.uid);
 */
```

---

**참고**: 나머지 파일들(components, pages, services, types, utils 등)은 파일이 많아 별도 MD 파일로 생성됩니다.

**다음 문서**: 
- `08-FRONTEND-SRC-COMPONENTS.md`: components (전체)
- `09-FRONTEND-SRC-PAGES.md`: pages (전체)
- `10-FRONTEND-SRC-SERVICES.md`: services (전체)
- `11-FRONTEND-SRC-TYPES-UTILS.md`: types, utils, data, test


